                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ( My Editor and extensions load screen)                                                                                         6 VIEWS EDIT.BLK   ( make the editor viewable)                  OPEN EDIT.BLK                                                                                                                   3 29 THRU                                                                                                                       CR .( Screen editor and extensions loaded )                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ( Set path)   HEX                                                                                                               CODE @PATH ( a - \ read the current path to an address)            AX POP AX INC  SI PUSH  AX SI MOV  0 # DL MOV                   47 # AH MOV  21 INT  SI POP  NEXT C;                                                                                         CODE !PATH ( a - f)                                                DX POP  3B # AH MOV  21 INT                                     3 # AX CMP  0= IF  -1 # AX MOV  ELSE  AX AX XOR THEN            AX PUSH  NEXT  C;                                                                                                            : .PATH   0 19 BDOS  41 + EMIT  ." :\" HERE @PATH  HERE 1+         BEGIN  DUP C@ WHILE DUP C@ EMIT 1+ REPEAT DROP ;             : CD   BL WORD  COUNT DUP 0= IF .PATH 2DROP                        ELSE  OVER +  0 SWAP C!  !PATH  ABORT" Invalid path "           THEN ;                                                       ( Bios video display interface)   HEX                                                                                           CODE AT ( x y)                                                     AX POP  AL DH MOV  AX POP  AL DL MOV                            2 # AH MOV  0 # BH MOV  10 INT  NEXT C;                                                                                      CODE XY@ ( - x y)                                                  3 # AH MOV  0 # BH MOV  10 INT                                  AX AX SUB  DL AL MOV  AX PUSH  DH AL MOV  AX PUSH  NEXT C;                                                                   VARIABLE VSEG ( the video page number)                          : COLOR   B800 VSEG ! ;    COLOR ( my default)                  : MONO    B000 VSEG ! ;                                                                                                         CODE VMODE@ ( - n \ lsb= vmode, msb=vpage)                         0F # AH MOV  10 INT  AH AH SUB  BH AH MOV  AX PUSH  NEXT C;  ( Extended memory access)   DECIMAL                                                                                             CODE MY-SEG ( - seg)   CS PUSH  NEXT C;                                                                                         CODE L@ ( seg off - n)                                             BX POP  DS AX MOV  DS POP  0 [BX] PUSH  AX DS MOV  NEXT C;   CODE L! ( n seg off)                                               BX POP  DS AX MOV  DS POP  0 [BX] POP  AX DS MOV  NEXT C;                                                                    CODE LCMOVE ( seg-off-f seg-off-t #)                               CLD  IP BX MOV                                                  CX POP  DI POP ES POP  SI POP DS POP  REP  BYTE MOVS            CS AX MOV  AX DS MOV  AX ES MOV  BX IP MOV  NEXT  C;                                                                         : L2@ ( seg off - d)   2DUP 2+ L@  ROT ROT  L@ ;                : L2! ( d seg off)   ROT >R  2DUP R> ROT ROT L!  2+ L! ;        ( Faster crt interface)   HEX                                                                                                   VARIABLE ATTRIBUTE   7 ATTRIBUTE !    0 ,                       VARIABLE BLANKING    0 BLANKING  !                                                                                              LABEL +BLANKING                                                    BLANKING #) DX MOV  DX DX OR  0= IF  RET  THEN                  1 # BX MOV  3DA # DX MOV                                        BEGIN  0 AL IN  BX AL TEST  0<> UNTIL                           3d8 # DX MOV  25 # AL MOV  0 AL OUT  RET  C;                 LABEL -BLANKING                                                    BLANKING #) DX MOV  DX DX OR  0= IF  RET  THEN                  3D8 # DX MOV  2D # AL MOV  0 AL OUT  RET  C;                                                                                                                                                                                                                    ( Continued..)   HEX                                                                                                         CODE FTYPE ( a # x y)   CLD                                        AX POP  0A0 # BX MOV  BX MUL                                    DI POP  DI DI ADD  AX DI ADD                                    CX POP  BX POP   SI PUSH  BX SI MOV                             HIDDEN VSEG  ASSEMBLER #) ES MOV   ATTRIBUTE #) AH MOV          +BLANKING #) CALL                                               BEGIN  AL LODS  AX STOS  CX DEC  0= UNTIL                       -BLANKING #) CALL                                               SI POP  DS AX MOV  AX ES MOV  NEXT  END-CODE                                                                                 CODE PAGE ( home and clear to end of screen)                       2 # AH MOV  0 # DX MOV  0 # BH MOV  10 INT                      20 # AL MOV  ATTRIBUTE #) BL MOV  0 # BH MOV                    7d0 # CX MOV  9 # AH MOV  10 INT  NEXT C;   ' PAGE IS DARK   ( Listing)   DECIMAL                                                                                                            VARIABLE OLDSCR                                                 : OTHER ( n - n)   DUP  SCR @ = NOT IF  SCR @ OLDSCR !  THEN ;                                                                  : FRAME                                                            PAGE  FILE?  CR ." SCR #"  16 0 DO  CR I 3 U.R  LOOP CR ;                                                                    : <LIST> ( scr)   0 MAX CAPACITY 1- MIN                            5 1 AT  DUP 5 U.R  DUP SCR !  BLOCK                             16 0 DO  DUP 64 4 I 2+ FTYPE  64 +  LOOP DROP ;                                                                              : LIST ( scr)   OTHER FRAME <LIST>  0 19 AT ;                                                                                   : VIEW ( - <name>)   [ DOS ]  ' @VIEW  ?DUP                        IF   2* VIEW-FILES + PERFORM OPEN-FILE  THEN  LIST ;            ( Listing)   DECIMAL                                                                                                         : ADV ( n)   SCR @ +  0 MAX  LIST ;                             : L    0 ADV ;                                                  : B   -1 ADV ;                                                  : N    1 ADV ;                                                                                                                  : G   SCR @ LOAD ;                                              : O   OLDSCR @ LIST ;                                                                                                           : Q   A L ;                                                                                                                     : CASE   COMPILE OVER COMPILE = [COMPILE] IF COMPILE DROP ;        IMMEDIATE                                                    : ;THEN   COMPILE EXIT  [COMPILE] THEN ;   IMMEDIATE                                                                            ( Blocks, Obliterate)                                                                                                           : CLEAN ( n)   BUFFER  1024 BLANK  UPDATE ;                     : ?FLUSH ( n)   #BUFFERS MOD 0= IF FLUSH THEN ;                                                                                 : BLOCKS ( f t #)                                                  >R  2DUP < IF ( backwards)                                         R@ + 1-  SWAP  R@ + 1-  SWAP ( f' t')                           R> 0 DO  2DUP (COPY)  SWAP 1- SWAP 1-  I ?FLUSH  LOOP        ELSE ( forwards)                                                   R> 0 DO  2DUP (COPY)  SWAP 1+ SWAP 1+  I ?FLUSH  LOOP        THEN  2DROP  FLUSH  ;                                                                                                        : OBLITERATE ( f #)                                                BOUNDS DO  I CLEAN  I ?FLUSH  LOOP  FLUSH ;                                                                                  ( MYEDIT - moving the cursor)                                                                                                   VOCABULARY MYEDIT   ONLY  FORTH ALSO  MYEDIT ALSO  DEFINITIONS                                                                  VARIABLE CURSOR                                                 : ^C ( - a)   SCR @ BLOCK CURSOR @ + ;                                                                                          : +C   CREATE , DOES> @ CURSOR @ + 1023 AND CURSOR ! ;                                                                           -64 +C UP     64 +C DOWN     1 +C RIGHT                        -256 +C UP4   256 +C DOWN4   -1 +C LEFT                                                                                         : TAB   CURSOR @ 4 + 1020 AND CURSOR ! ;                        : RETURN   CURSOR @ 64 +  960 AND  CURSOR ! ;                                                                                   : HOME   0 CURSOR ! ;                                              ( Screen interface)                                                                                                          : XY ( - x y)   CURSOR @ 64 /MOD  2 + SWAP 4 + SWAP ;                                                                           : PUT   XY AT ;                                                                                                                 : #EOL ( - n)   64  CURSOR @ 63 AND - ;                         : #EOS ( - n)   960 CURSOR @ - ;                                                                                                : .EOL   ^C #EOL XY  FTYPE ;                                    : .EOS   CURSOR @ >R  BEGIN  .EOL RETURN  CURSOR @ 0= UNTIL        R> CURSOR ! ;                                                                                                                : WIPE ( to end of screen)   ^C #EOS 64 +  BLANK .EOS UPDATE ;  : BLOT ( to end of line)     ^C #EOL BLANK .EOL UPDATE ;                                                                           ( Status reporting)                                                                                                          CREATE SCREENS   10 ALLOT   SCREENS 10 ERASE                    : .SCREENS   28 0 AT  ." others "                                  10 0 DO  I SCREENS + @ 4 U.R  2 +LOOP ;                                                                                      VARIABLE INSERTING                                              : .INS   65 0 AT                                                   INSERTING @ IF  ." ins"  ELSE ." ovr" THEN ;                 : *INS   INSERTING @ 0= INSERTING !  .INS ;                                                                                     VARIABLE LS                                                     : .LS ( print the line stack)                                      0 19 AT                                                         LS @ ?DUP IF  DUP 64 / 3 .R ." {"  PAD + 64 TYPE  ." }"            ELSE  70 SPACES THEN ;                                       ( Different screens)                                                                                                         : .CURSOR   18 0 AT  CURSOR @ 64 /MOD  3 .R 3 .R ;              : .STAT   .INS .LS .SCREENS ;                                                                                                   : ADV ( n)   SCR @ + <LIST> ;                                   : N   1 ADV ;               : B   -1 ADV  ;                     : L   0 ADV .STAT ;         : SHADOW   Q L ;                                                                                    : UNDO ( the edited screen)   DISCARD L ;                                                                                       : MARK ( n)   2* SCREENS + SCR @ SWAP !  .SCREENS ;             : GOTO ( n)   2* SCREENS + @ ?DUP IF SCR ! L THEN ;                                                                             : TO-EOL   RETURN UP  ^C 64 -TRAILING                              DUP IF  1+  63 MIN  THEN  CURSOR @ +  CURSOR !  DROP ;          ( Line stack)                                                                                                                : CUT ( the current line)                                          64 LS +!  PAD LS @ +  DUP 64 BLANK  ^C SWAP #EOL CMOVE          DOWN .LS ;                                                   : PASTE ( to the current line)                                     LS @ IF PAD LS @ + ^C #EOL CMOVE  UPDATE  .EOL  -64 LS +!       UP .LS THEN ;                                                                                                                : <DELETE>                                                         #EOL 1- DUP  ?DUP IF  ^C DUP 1+ SWAP ROT CMOVE  THEN            32 ^C ROT + C! UPDATE ;                                                                                                      : DELETE   <DELETE> .EOL ;                                      : BACKSPACE   LEFT  INSERTING @ IF DELETE THEN ;                                                                                   ( By words)                                                                                                                  : <>END ( n - n f)   DUP 1024 < ;                               : =BL ( n - n f)   ^C C@ 32 = ;                                 : <>BL ( n - n f)   ^C C@ 32 = 0= ;                                                                                             : WORD>   0 BEGIN  <>END <>BL AND WHILE  1+ RIGHT  REPEAT          BEGIN <>END =BL AND WHILE 1+ RIGHT REPEAT DROP ;             : <WORD   LEFT  0 BEGIN  <>END =BL AND WHILE  1+ LEFT  REPEAT      BEGIN <>END <>BL AND WHILE 1+ LEFT REPEAT DROP RIGHT ;                                                                       : -WORD   CURSOR @  ^C  WORD> ^C  SWAP - SWAP CURSOR !  #EOL MIN   ?DUP IF 0 DO <DELETE> LOOP .EOL THEN ;                                                                                       : -DIALOG   0 21 AT  240 SPACES  0 22 AT ;                      : DIALOG   -DIALOG  0 22 AT  ." cmd> " QUERY INTERPRET ;           ( Split and join)                                                                                                            : SPLIT ( the line at the cursor)                                  #EOS 0< NOT IF  ^C DUP 64 + #EOS CMOVE>                                   ^C 64 BLANK  UPDATE  .EOS   THEN ;                 : JOIN ( the lines at the cursor)                                  #EOS 0< NOT IF  ^C DUP 64 + SWAP #EOS CMOVE                               ^C #EOS +   64 BLANK  UPDATE  .EOS  THEN ;                                                                         : OVERSTRIKE ( char)   ^C C!  ^C 1 XY FTYPE  RIGHT UPDATE ;                                                                     : <INSERT> ( char)   #EOL 1- ?DUP IF  ^C DUP 1+ ROT CMOVE>  THEN   ^C C!  UPDATE ;                                              : INSERT ( char)   <INSERT> .EOL RIGHT ;                                                                                        : CHARACTER ( c)   INSERTING @ IF INSERT ELSE OVERSTRIKE THEN ;    ( Matching)                                                  CODE $ZMATCH ( sa s# pa - a f)                                     AX AX SUB  DX DX SUB                                            BX POP   0 [BX] DL MOV  DX DEC  BX INC  0 [BX] AL MOV  BX INC   CX POP  DI POP  SI PUSH                                         BEGIN                                                              REPNZ BYTE SCAS  0<> IF                                            SI POP  DI PUSH  CX PUSH  NEXT  THEN                         CX PUSH  DI PUSH                                                DX CX MOV  BX SI MOV                                            REPZ BYTE CMPS  0= IF                                              DI POP  DI DEC  CX POP                                          SI POP  DI PUSH  CX PUSH  NEXT  THEN                         DI POP  CX POP                                               AGAIN                                                        NEXT C;                                                            ( Searching)                                                                                                                 CREATE $FIND  80 ALLOT                                                                                                          : PLACE ( a)   96 WORD  SWAP OVER C@ 1+ CMOVE ;                                                                                 : SEARCH ( - f \ search one screen)                                SCR @ BLOCK  DUP  CURSOR @ +  1024 CURSOR @ -                   $FIND $ZMATCH                                                   IF  SWAP - CURSOR !  -1 EXIT THEN                               2DROP  0 CURSOR !  0 ;                                                                                                                                                                                                                                                                                                                                                                          ( Searching)                                                                                                                 VARIABLE SLIM                                                                                                                   : <SEARCH> ( - f)                                                  0 18 AT  ."          "                                          RIGHT  SCR @ >R                                                 BEGIN  SEARCH  IF R> DROP  L  -1 ;THEN                             1 SCR +!  SCR @ SLIM @ >  UNTIL                               R> SCR !  L                                                    0 18 AT  ." not found"  0 ;                                                                                                  : SEARCHING   <SEARCH> DROP ;                                                                                                   : S ( n)   SLIM !  LEFT  SEARCHING ;                                                                                               ( Replacing)                                                                                                                 : DELETES ( n)     0 DO  <DELETE>  LOOP ;                       : INSERTS ( a #)                                                   OVER +  BEGIN ( a a')                                              2DUP - WHILE  1- DUP C@ <INSERT>  REPEAT  2DROP ;                                                                         CREATE $REPLACE   80 ALLOT                                                                                                      : REPLACE   $FIND C@ DELETES  $REPLACE COUNT INSERTS .EOL ;                                                                     : >REPLACE   REPLACE  SEARCHING ;                                                                                               DEFER MORE   ' NOOP IS MORE                                                                                                                                                                     ( INSERT AND DELETE SCREENS)   DECIMAL                                                                                          : ?EXTEND-FILE                                                     CAPACITY 1- BLOCK  1024 -TRAILING IF  DROP  [ FORTH ] 1 MORE       CR  ." >> 1 screen added to file, any key to continue..."       7 EMIT  KEY DROP  THEN ;                                                                                                  : REMAINING ( - f t #)   SCR @  DUP 1+  CAPACITY SCR @ - 1- ;                                                                   : INSERT-SCR   ?EXTEND-FILE  REMAINING BLOCKS  SCR @ ;          : DELETE-SCR   REMAINING >R SWAP R> BLOCKS CAPACITY 1- ;        : SPREAD                                                           -DIALOG  ." (I)nsert or (D)elete a screen? "  KEY 32 OR         ASCII i CASE  ." Insert"  INSERT-SCR  CLEAN L  ;THEN            ASCII d CASE  ." Delete"  DELETE-SCR  CLEAN L  ;THEN                          DROP 7 EMIT ." Aborted " ;                        ( Function key interface)                                    : KEYPAD   KEY                                                     62 CASE SPREAD ;THEN                                            71 CASE HOME   ;THEN            79 CASE TO-EOL ;THEN            73 CASE B      ;THEN            81 CASE N      ;THEN            80 CASE DOWN   ;THEN            72 CASE UP     ;THEN            75 CASE LEFT   ;THEN            77 CASE RIGHT  ;THEN            82 CASE *INS   ;THEN            83 CASE DELETE ;THEN            59 CASE FLUSH  ;THEN            60 CASE UNDO L ;THEN            64 CASE 0 GOTO ;THEN           109 CASE 0 MARK ;THEN            65 CASE 1 GOTO ;THEN           110 CASE 1 MARK ;THEN            66 CASE 2 GOTO ;THEN           111 CASE 2 MARK ;THEN            67 CASE 3 GOTO ;THEN           112 CASE 3 MARK ;THEN            68 CASE 4 GOTO ;THEN           113 CASE 4 MARK ;THEN            31 CASE SEARCHING ;THEN         19 CASE REPLACE ;THEN           44 CASE >REPLACE ;THEN     MORE  7 EMIT DROP ;                  ( Control keys)                                                                                                              : ---   7 EMIT ;                                                : JAM   KEY CHARACTER ;                                         VARIABLE FINISHED                                               : EGRESS   -1 FINISHED ! ;                                                                                                      CREATE CONTROLS                                                 ]  ( 00) KEYPAD     <WORD     DIALOG  DOWN4                        ( 04) RIGHT      UP        WORD>   DELETE                       ( 08) BACKSPACE  TAB       BLOT    CUT                          ( 12) PASTE      RETURN    SPLIT   HOME                         ( 16) JAM        SHADOW    UP4     LEFT                         ( 20) -WORD      WIPE      *INS    B                            ( 24) DOWN       JOIN      N       EGRESS                       ( 28) ---        DIALOG    ---     ---       [               ( My EDITOR)                                                                                                                    ONLY  FORTH ALSO DEFINITIONS                                    : CONT   [ MYEDIT ]   0 FINISHED !                                 BEGIN  .CURSOR  PUT KEY                                            DUP 32 < IF  2* CONTROLS + @ EXECUTE                                     ELSE  CHARACTER                                                 THEN                                                FINISHED @ UNTIL  0 18 AT  ." Done " ;                                                                                       : ED   FRAME  [ MYEDIT ] L CONT  ;                              : EDIT ( n)   0 MAX CAPACITY 1- MIN  SCR !  ED ;                : R   [ MYEDIT ]  $REPLACE PLACE REPLACE ;                      : S   [ MYEDIT ]  $FIND PLACE S ;                                                                                               ONLY  FORTH ALSO DEFINITIONS                                    ( QX etc)                                                                                                                       : QX ( n)   PAD 6 - 27 BLANK  PAGE  0 22 AT                        0 MAX  60 0 DO ( n)                                                DUP CAPACITY >= DUP IF  ." QX out of range"  THEN               KEY? OR  IF LEAVE THEN                                          DUP 0 <# #S #> 2DROP  DUP BLOCK PAD 1+  20 CMOVE  1+            PAD 5 - 26  I 21 /MOD 26 * SWAP 1+ FTYPE                     LOOP  OTHER  SCR ! ;                                                                                                         : NX   SCR @ QX ;                                               : LX   SCR @ 60 - QX ;                                          : BX   SCR @ 120 - QX ;                                                                                                         : PRINT   PRINTING ON ;                                         : ||      12 EMIT  PRINTING OFF ;                               ( Will Baden's EXPECT)   DECIMAL                                                                                                : ~ENCODE ( char - a)                                              BASE @ >R DECIMAL                                               0 <#  BL HOLD  #S  ASCII ~ HOLD  #> ( a #)                      1- OVER 1- C!  1-                                               R> BASE ! ;                                                                                                                  : ~STROKE ( vector here on special characters)                     drop  KEY ~ENCODE FIND IF  EXECUTE  ELSE  DROP  THEN ;                                                                       ' ~STROKE CC-FORTH !                                            ' BACK-UP CC-FORTH 27 2* + !                                                                                                    : ~73 ( pgup)   B ;                                             : ~81 ( pgdn)   N ;                                                ( Remembering lines of input)                                                                                                VARIABLE ^HELD                                                                                                                  CREATE HELD   81 8 * ALLOT ( 8 lines of 80 characters + count)         HELD   81 8 * ERASE                                                                                                      : MCR-IN ( max adr len char)   DROP  DUP SPAN !                    ?DUP IF ( max adr len)                                             HELD  DUP 81 +  [ 7 81 * ] LITERAL CMOVE>                       HELD C!  2DUP HELD 1+  ROT CMOVE  THEN                       OVER BL EMIT  -1 ^HELD ! ;                                                                                                   ' MCR-IN CC-FORTH 26 + !                                                                                                                                                                           ( Recalling lines of input)                                                                                                  : RETRIEVE ( max adr len ^held - max adr len)                      81 * HELD + >R   0 BACK-UP DROP ( max adr)                      R@ 1+ OVER R@ C@ CMOVE  R@ COUNT TYPE  R> C@ ;                                                                               : ~72 ( up arrow \ back one line)                                  ^HELD @ 1+ 7 AND  DUP ^HELD ! ( n)  RETRIEVE ;               : ~80 ( down arrow \ forward one line)                             ^HELD @ 1- 7 AND  DUP ^HELD ! ( n)  RETRIEVE ;                                                                               : STROKES ( max adr len adr #)                                     4 PICK 3 PICK - MIN                                             BOUNDS DO I C@ CHAR LOOP ;                                                                                                   \ ie : ~59 ( f1)  " HERE 100 DUMP " STROKES ;                   EDIT - an interactive screen editor for F83                                                                                     by: Rick VanNorman                                                  1080 Hall Road                                                  Palm Bay, FL  32905                                             (407) 728 0002                                                                                                              This code is released into the public domain.  It may be freely distributed and used in any way, provided this copyright travelswith it.                                                                                                                        (c) 1988 by Rick VanNorman                                                                                                      Thank you for your support.                                                                                                                                                                     This editor is the conclusion of 8 years of building screen     editors in Forth.  It is probably the last screen editor that I will ever write, as I am moving toward a file-based environment.This editor is compact and very fast, but not always obvious.   I make no appologies for it -- I wrote it, use it, and love it. It is mine.  I hope you enjoy it.                                                                                               The extensions included, in my opinion, make F83 a much more    friendly environment.                                                                                                           My thanks to Will Baden for his extensions to EXPECT.                                                                                                                                                                                                                                                                           Rick VanNorman  16 February 1989                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                Set path                                                                                                                        @PATH ( address - )                                                Read the current directory as an ASCIIZ string into address+1                                                                !PATH ( address - flag )                                           Using the string at address, set a new current directory.  If   the desired path doesn't exist, return a true flag.                                                                          .PATH ( - )                                                        Read the current path and print it.                                                                                          CD          usage: CD this/that/path   or:  CD                     Set a new directory to the text following.  If no text          follows, assume the user desires a report of the current        directory.                                                   Bios console/printer interface                                                                                                  AT          ( x y)                                                 Position the cursor at column X, row Y.                                                                                      XY@         ( - x y)                                               Return the X,Y position of the cursor.                                                                                       VSEG        ( - a)                                                 A variable holding the video segment address.                                                                                COLOR       ( - )                                                  Sets VSEG for a color display.                               MONO        ( - )                                                  Sets VSEG for a mono-chrome display.                                                                                         Extended memory access                                                                                                          MY-SEG      ( - seg)                                               Return Forth's segment address.                              CODE L@     ( seg off - n)                                         Read  a 16 bit number from seg:offset .                      CODE L!     ( n seg off)                                           Write a 16 bit number   to seg:offset .                      CODE LCMOVE ( seg-off-f seg-off-t #)                               Move memory, byte by byte, from a segment:offset address        to a segment:offset address.  The count for the move is         limited to 65535 bytes.                                      L2@         ( seg off - d)                                         Read  a 32 bit number from seg:offset .                      L2!         ( d seg off)                                           Write a 32 bit number to   seg:offset .                      Faster crt interface                                                                                                            ATTRIBUTE                                                          The display attribute used by PAGE and FTYPE.                BLANKING                                                           An indicator of whether the user wishes to blank the display    before writing characters to it.  Set by "BLANKING ON" in the   command line invocation of TERM.                                                                                             +BLANKING                                                          Conditionally blank the display before continuing.           -BLANKING                                                          Conditionally unblank the display before continuing.                                                                                                                                                                                                         Faster crt interface                                                                                                            FTYPE ( a # x y)                                                   This routine (using a fixed attribute) will write a string      directly into video ram.  It checks blanking for CGA if the     BLANKING variable is non-zero.  The                             string may be located anywhere on the screen (25x80 only)       specified by X,Y .                                                                                                           PAGE                                                               Send the cursor to 0,0 and clear the display.                                                                                                                                                                                                                                                                                                                                                Listing                                                                                                                         OLDSCR   holds the other screen number.                         OTHER ( n)   SCR @ = NOT IF  SCR @ OLDSCR !  THEN ;                If screen N is not the same as SCR, remember SCR in OLDSCR . FRAME ( n)                                                         Draw the listing frame specifically for screen N .           <LIST> ( n)                                                        Display the text of a screen.                                                                                                LIST ( n)                                                          While monitoring OTHER, list a given screen.                                                                                 VIEW            use: VIEW WORDS                                    List the screen containing the word specified by lookup         via the 'VIEW field of the header.                           Listing                                                                                                                         ADV ( n)   Advance the screen number and list.                  L          Relist the current screen.                           B          Move back one screen.                                N          Move forware one screen.                                                                                             G           Load the current screen.  My personal favorite word.O           List the other screen.                                                                                              Q           Alternate between source and shadow.                                                                                CASE        Compile a simple case structure.                                Used as      :  nn CASE ... ;THEN                               Forth code is:  nn OVER = IF DROP ... EXIT THEN     ;THEN       Compile an EXIT before a THEN .                     Blocks                                                                                                                          BLOCKS ( f t #)                                                    Moves screens just like CMOVE moves bytes.  Never overwrites;   moves in both directions automatically.                      OBLITERATE ( f #)                                                  Clears a range of screens.  Is difficult to type on purpose.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 MYEDIT - moving the cursor                                                                                                      MYEDIT   Is the editor vocabulary.                                                                                              CURSOR   The cursor position in the current block 0..1023 .     ^C ( - a)   Returns the address of the cursor in memory.                                                                        +C   A defining word to simplify up, down, etc.                                                                                 UP     DOWN     RIGHT   simply move the cursor, clipping        UP4    DOWN4    LEFT    at the top and bottom of a screen.                                                                      TAB      Moves the cursor to the next "4 MOD" column.           RETURN   Moves the cursor down and to the start of line.                                                                        HOME     Moves the cursor to the top of the screen.             Screen interface                                                                                                                XY ( - x y)   Return the x,y position of cursor, crt adjusted.                                                                  PUT           Position the physical cursor properly.                                                                            #EOL ( - n)   Characters from cursor to the end of line.        #EOS ( - n)   Characters from cursor to start of line 15.                                                                       .EOL          Print from cursor to the end of line.             .EOS          Print from cursor to the end of line, continue                  and update remainder of screen.                                                                                   WIPE          Blanks the screen from cursor to end.             BLOT          Blanks the line   from cursor to end.                                                                             Status reporting                                                                                                                SCREENS     Is an array holding the alternate screens.          .SCREENS    Display the alternate screen numbers as status.                                                                     INSERTING   Is a variable holding the insert/overwrite state.   .INS        Displays the insert/overwrite state.                *INS        Toggles the insert/overwrite state.                                                                                 LS          Is a variable pointing to the line stack.           .LS         Prints the top of the line stack below the screen.                                                                                                                                                                                                                                                                                                                                  Different screens                                                                                                               .CURSOR     Display the x,y cursor position.                    .STAT       Update all status displays.                                                                                         ADV ( n)    Move to another screen, but don't redraw the frame. N  B        Move +/- one screen.                                L           Relist the current screen.                          SHADOW      Alternate between source and shadow.                UNDO        Discard changes, re-read from disk.                                                                                 MARK ( n)   Save the current screen as alternate N .            GOTO ( n)   Move to screen saved as alternate N .                                                                               TO-EOL      Move the cursor to the end of the line.                                                                             Line stack                                                                                                                      CUT         Moves text from the cursor to the end of line to                the line stack (padded to 64 chars with blanks).    PASTE       Moves text from the line stack to the cursor,                   truncating at the end of the line on the screen.                                                                    <DELETE>    Delete the character under the cursor and pull the              rest of the line over one character.                                                                                DELETE      Delete and refresh the display.                     BACKSPACE   Move the cursor left.  If we are inserting, delete              the character under the cursor.                                                                                                                                                                                                                     By words                                                                                                                        <>END ( n - n f)    true if count N is not at end of screen.    =BL   ( - f)        True if character under cursor is BL .      <>BL  ( - f)        True if character under cursor is not BL .                                                                  WORD>               Move right to the start of the next word.   <WORD               Move left  to the start of the next word.                                                                   -WORD               Delete the word under the cursor.                                                                           DIALOG              Prompt the user a single line of Forth to be                    executed.  Very handy for calculating                           constants.                                                                                                                                                                  Split and join                                                                                                                  SPLIT   Split the current line at the cursor.  Line 15 is lost. JOIN    Join the current line and the next line at the cursor.                                                                  OVERSTRIKE ( char)   Put the character into the buffer and                           print it on the crt.                       <INSERT> ( char)     Insert the character into the buffer.  Move                     the rest of the line over one column.                           Refresh the display to the end of the line.INSERT ( char)       Insert the character and refresh the                            display to the end of the line.                                                                            CHARACTER ( char)    Handle one character.                                                                                                                                                      Matching                                                                                                                        $ZMATCH ( sa s# pa - a f)                                          Given a source address, the number of bytes in the source       text, and the address of a counted pattern, check for           a string match.  Case is significant always.  If a match is     found, return TRUE and the address of the match.  If no match   was found, return FALSE ; the address is useless in this        case.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        Searching                                                                                                                       $FIND           A buffer for the search pattern.                                                                                PLACE ( a)      Parse a string to the address.                                                                                  SEARCH ( - f)                                                      Search the current screen for the pattern in $FIND.  If found   position the cursor at the start of the match and return        TRUE.  If not found, position the cursor at the top of the      screen and return FALSE.                                                                                                                                                                                                                                                                                                                                                                     Searching                                                                                                                       SLIM        Holds the screen number to search thru.                                                                             <SEARCH> ( - f)                                                    Blank the status display and begin searching the screens from   the current screen through SLIM.  If the string was not found   return FALSE with the cursor at the top of the screen where     the search started.  If found, return TRUE and position the     cursor on the string.                                                                                                        SEARCHING                                                          Same as <SEARCH> but return no flag.                                                                                         S ( n)          use:  29 S THIS IS A TEST STRING                   Search thru screen N for the following string.               Replacing                                                                                                                       DELETES ( n)    Delete N characters under the cursor.           INSERTS ( a #)  Insert # characters from A at the cursor.                                                                       $REPLACE        A buffer for the replace pattern.                                                                               REPLACE         Replace text under the cursor.                                                                                  >REPLACE        Replace and search again.                                                                                       MORE            A vector for extending the function key                         execution routine.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              Function key interface                                                                                                          KEYPAD                                                             A function key execution case.  First, read the next key-       stroke.  Then execute the case statements until a match is      found.  If no match, execute the MORE extension.  If MORE       returns, there was no match, so ring the bell and return.       The keys are referenced by scan codes and are documented        elsewhere.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   Control key interface                                                                                                           ---     Rings the bell for undefined control characters.                                                                        JAM         Put -any- character into the screen.                FINISHED    True if editing is complete.                        EGRESS      Time to exit, set the flag.                                                                                         CONTROLS    Is a compiled array of execution addresses.  This               probably should be implemented as  nn CASE .. ;THEN             for consistency and all that, but this works and I              don't really care.  The controls are documented                 elsewhere.  Function keys return a zero, which                  vectors to KEYPAD for scan code processing.                                                                                                                                         My EDITOR                                                                                                                       CONT                                                               Is the main editor loop.  It prints status, accepts keys,       routes them to either control or text functions, and notices    when to quit.                                                                                                                ED          Re-edits the current screen.                        EDIT ( n)   Edits screen N .                                                                                                    S           Searches for text.                                              Use:   29 S this is a test pattern                  R           Replaces found text.                                            Use:      R this replaces the test pattern                                                                          These are used interactively in the dialog routine.             QX etc                                                                                                                          QX ( n)                                                            Prints a quick index (the first 20 characters of each screen    only) of 60 screens at a time starting at screen N.                                                                          NX   Print the next QX .                                        LX   Print the current QX .                                     BX   Print the previous QX .                                                                                                    PRINT  vectors console output to the printer.                   OK     send a "page feed" to the printer, then vectors console         output to the display.                                                                                                                                                                                                                                   Blocks                                                                                                                          TRULY       Inquires whether the user really meany what he said.                                                                BLOCKS ( f t #)                                                    Moves screens just like CMOVE moves bytes.  Never overwrites;   moves in both directions automatically.                      OBLITERATE ( f #)                                                  Clears a range of screens.  Is difficult to type on purpose.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 